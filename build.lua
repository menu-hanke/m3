local function build_cdef(fname, version)
	local buffer = require "string.buffer"
	local cdef = buffer.new()
	local cfunc = buffer.new()
	local cfuncdef = {}
	local fp = (fname and fname ~= "-") and assert(io.open(fname, "r")) or io.stdin
	local out_luadef = io.open("m3_cdef.lua", "w")
	local out_cdef = io.open("cdef.c", "w")
	out_luadef:write([[
-- autogenerated by build.lua - don't edit this file manually.
local ffi = require 'ffi'
local _ = {}
	]])
	if version then
		out_luadef:write("_.version = '", version, "'\n")
	end
	local line
	local parens = { ["("]=1, [")"]=-1, ["["]=2^8, ["]"]=-2^8, ["{"]=2^16, ["}"]=-2^16 }
	local function die(s) io.stderr:write("luadef: ", s, "\n") os.exit(1) end
	local function readbalanced(buf)
		local match = 0
		while true do
			buf:put(line)
			for p in line:gmatch("[%(%)%[%]{}]") do
				match = match + parens[p]
			end
			if match == 0 then break end
			buf:put(" ")
			line = fp:read("*l")
			if not line then die("unexpected eof (unbalanced brackets)") end
		end
	end
	while true do
		line = fp:read("*l")
		if not line then break end
		if line:match("@cdef@") then
			line = line:gsub("@cdef@", "")
			readbalanced(cdef)
			if not line:match(";%s*$") then cdef:put(";") end
			cdef:put("\n")
		elseif line:match("@cfunc@") then
			line = line:gsub("@cfunc@", "")
			readbalanced(cfunc)
			-- i know this is not how you parse C code but it's good enough for our purposes
			local ret, name, args = cfunc:get():match("^[%s]*(.-)([%w_]+)%((.+)%)[%s;]*$")
			if not ret then die("C function declaration is invalid or too complex") end
			table.insert(cfuncdef, {name=name, decl=string.format("%s (*%s)(%s)", ret, name, args)})
		elseif line:match("@lua@") then
			out_luadef:write((line:gsub("@lua@", "")), "\n")
		end
	end
	out_luadef:write(string.format("ffi.cdef [[ %s ]]\n", cdef))
	-- TODO: generate separate versions of this assignment for the host and worker
	out_luadef:write("local m3_C = ffi.cast([[struct {\n")
	for _,cf in ipairs(cfuncdef) do
		out_luadef:write(cf.decl, ";\n")
	end
	out_luadef:write("} *]], ...)\n")
	for _,cf in ipairs(cfuncdef) do
		out_luadef:write(string.format("_.%s = m3_C.%s\n", cf.name, cf.name))
	end
	out_luadef:write("return ffi.metatype('struct {}', {__index=_})()\n")
	out_cdef:write([[
// autogenerated by build.lua - don't edit this file manually.
#include "def.h"
#if !M3_AMALG
#include "sqlite/sqlite3.h"
]])
	for _,cf in ipairs(cfuncdef) do
		if cf.name:sub(1,3) == "m3_" then
			out_cdef:write("extern char ", cf.name, "[];\n")
		end
	end
out_cdef:write([[
#endif
M3_DATADEF struct m3_Cdef {
]])
	for _,cf in ipairs(cfuncdef) do
		out_cdef:write("void *", cf.name, ";\n")
	end
	out_cdef:write("} M3_CDEF = {")
	comma = ""
	for _,cf in ipairs(cfuncdef) do
		out_cdef:write(comma, "\n ", cf.name)
		comma = ","
	end
	out_cdef:write("\n};\n")
	out_luadef:close()
	out_cdef:close()
end

local function build_bcode(_, target, debuginfo, ...)
	local buffer = require "string.buffer"
	local arch = target:match("^[^%-]+")
	local modules = {}
	for _,m in ipairs({...}) do
		local name, source = m:match("^([^=]+)=(.*)$")
		if name == "jit" then
			local jit_modules = {"bc", "dump", "p", "v", "vmdef", "zone"}
			if arch == "x86_64" then
				table.insert(jit_modules, "dis_x86")
				table.insert(jit_modules, "dis_x64")
			else
				error("TODO")
			end
			for _,m in ipairs(jit_modules) do
				table.insert(modules, {name="jit."..m, source=source.."/jit/"..m..".lua"})
			end
		elseif name then
			table.insert(modules, {name=name, source=source})
		else
			table.insert(modules, {name=m:sub(1,-5), source=m})
		end
	end
	table.sort(modules, function(a,b) return a.name < b.name end)
	local buf = buffer.new()
	io.stdout:write("#define M3_BCODE_NUM ", #modules, "\n")
	io.stdout:write("static const uint32_t M3_BCODE_OFS[] = {");
	for _,m in ipairs(modules) do
		io.stdout:write(#buf, ",")
		local fp = assert(io.open(m.source, "r"))
		buf:put(m.name, "\0", string.dump(assert(load(fp:read("*a"), "="..m.name)), debuginfo=="0"))
		fp:close()
	end
	io.stdout:write("};\n")
	io.stdout:write("static const uint8_t M3_BCODE_DATA[] = {");
	local ptr, len = buf:ref()
	for i=0, len-1 do
		io.stdout:write(ptr[i], ",")
	end
	io.stdout:write("};\n")
end

local function build_amalg(fname, included)
	if included[fname] then
		return
	end
	if fname:sub(1,6) == "LuaJIT" then
		included[fname] = true
	end
	local fp = assert(io.open(fname, "r"))
	for line in fp:lines() do
		if line == "#pragma once" then
			included[fname] = true
		else
			local inc = line:match('#include[%s]+"([^"]+)"')
			if inc then
				local dir = fname:match("^(.*)/[^/]*$")
				if dir then
					inc = dir.."/"..inc
				end
				build_amalg(inc, included)
			else
				io.stdout:write(line, "\n")
			end
		end
	end
	fp:close()
end

local what = ...
if what == "cdef" then
	build_cdef(select(2, ...), select(3, ...))
elseif what == "bcode" then
	build_bcode(...)
elseif what == "amalg" then
	build_amalg(select(2, ...), {})
end
